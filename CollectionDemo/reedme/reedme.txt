集合体系：
----------|Collection   单例集合根接口
--------------|List   如果实现了List集合类。 具备特点：有序，可重复。
-----------------|ArrayList  底层维护了一个Object数组实现的。 特点：查询快，增删慢。
-----------------|LinkedList  底层用链表数据结构实现的。 特点：查询慢，增删快。
-----------------|Vector  底层通过维护一个Object数组实现的，实现与ArrayList是一样的。 但Vector线程是安全的，操作效率低
--------------|Set  若果是实现了Set接口的集合类，巨鳖特点：无序，不可重复。
-----------------|HashSet 底层通过哈希表实现的，特点：存取速度快。
				  HashSet实现原理：
				  	往HashSet中添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值，
				  	然后通过元素的哈希值经过以为等运算，就可以算出该元素在哈希表中的存储位置。
				  情况1：
				  	如果算出元素的存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。
				 情况2：
				 	如果算出该元素的存储位置目前已存在有其他元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，
				 	如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，否则将该元素添加
-----------------|TreeSet   如果元素具备自然顺序的特性，那么就按照元素自然顺序的特性进行排序存储。
					TreeSet 添加自定义元素：
						1.往TreeSet添加元素的时候，如果元素本身具备了自然顺序的特性，那么就按照元素自然顺序的特性进行排序存储。
						2.往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么该元素所属的类必须要实现Comparable
						接口，重写CompareTo（）方法，把元素的比较规则定义在该方法上。
						3.如果比较元素的时候 	，CompareTo方法返回的是0，那么该元素就被视为重复元素，不允许添加。（注意：TreeSet与HashCode，equals方法没有任何关系。）
						4.往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而元素所属的类也没有实现Comparable接口，那么必须要在创建TreeSet的时候传入一个比较器。
							如何自定义比较器：自定义一个类实现Comparator接口即可，把元素与元素之间的比较规则定义在compare方法上即可。
						5.往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而元素所属的类已经实现了Comparable接口，在传入TreeSet对象的时候也传入了比较器，
							那么是以比较器的比较规则优先使用。
								自定义比较器格式：
									Class 类名 implements Comparator{
									
									}